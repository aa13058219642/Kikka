AYA5的运行方式是比较接近C语言的，简单易读与不须使用诸多的头文件是AYA5成为初学编程的同学试写代码的一大便利。以下是吾辈总结的使用AYA5编程中遇到的常见问题。
1.关于函数名加On和不加On及加Select的区别
同一函数，比如OnFunction、Function、及Select.Function。其中，OnFunction的使用范围最高，你可以创建一个选项，比如"\q[函数,OnFunction,r1,r2,r3]"，点击这个选项，OnFunction函数即可运行，其中r1,r2,r3是参数，用来传递给OnFunction，其值分别对应reference0，reference1，reference2。对于Function，"\q[函数,Function,r1,r2,r3]"是不起作用的，它会自动寻找Select.Function的函数名并运行，如果没有，便跳过。所以Select.Function的函数名才能使"\q[函数,Function,r1,r2,r3]"起作用。但是这里有个问题，reference0，reference1，reference2并不对应r1,r2,r3，而是将Function这个名字作为reference0，所以在带参数的选项里调用的函数，应该使用加On的函数名，不带参数的涵数，可以使用加Select.的函数名，注意S应大写，"."不可省略

2.reference,_argc,_argv的关系
reference是使用者操作产生的返回，_argv是程序内部带参数调用的返回，而_argc是程序内部调用的返回参数的个数。
比如在OnKeyPress函数内部调用一个Function，这时键盘输入就被作为reference0传递给Function，Function内部再用reference0接收或赋值，如果调用的是Function(reference0),Function内部就用_argv[0]赋值,_argc就为1。

3.变量的赋初值，字符串与整形数字与浮点数字如何转换？
经常遇到这样一个问题，数字的自加变成字符的累加，这是由于字符串没有转换成整形数字，变量在接收返回值时，自动就转换成为与返回值类型相同的数据，比如在上一个函数调用它的时候："\q[函数,OnFunction,1,变量,%(变量),1.0,"1"]"。reference0为整形数字1；reference1为字符串"变量"；reference2为名叫“变量”的变量的内容；reference3为浮点数字1.0，在与reference3作加减乘除的运算中，自动转换成浮点，不过AYA支持的浮点位数有限，不能作高精度运算，仅能看作实数；reference4是字符“1”。用reference4赋值后作加减运算就会产生字符的累加，所以应使用TOINT(reference4)转换成整型数字1。在变量1==变量2这个运算中，值得注意。

4.关于脚本的接续
AYA5是按行从左到右从上至下编译脚本内容的，如果一行未完就跳至下一行，就会有错误提示；
"这是一个脚本，\w9\w9它是从左到右运行的
\w9\n这是下一句话"
这个出错了，原因是接续不全，应该是"这是一个脚本，\w9\w9它是从左到右运行的/
\w9\n这是下一句话"
其中，/是接续符，表示下面的内容与之前的内容是连在一起的，这够成完整的一行。

5.何时换行，何时加{}与不加{}
if a==b;a=1
这是一个完整的表达，它没有换行，也没有加{}，因为分号;的应用使它后面的a=1变成关系式的一部分。
再来看
if a==b;a=1;b=2
关系式起作用的是哪一部分，答案是a=1,因为在不加{}的情况下，if 语句能识别一行的内容，由于分号把b=2变成a=1的下一行，因此b=2就不受if语句的约束，要使if起作用应该这样if a==b;{a=1;b=2}
这个在if a==b;1;return中犹为注意，这样写不受条件式的约束脚本运行就结束了。

6.全局变量与区域变量的使用条件
a=1;_b=2。
在上式中，a为全局变量，_b为区域变量，全局变量在整个人格里都起作用，而区域变量只在当前{}括号内部起作用。那么，什么时候用全局变量，什么时候用区域变量呢？
涉汲到存储永久性的内容用全局变量，如果只是在当前函数中作临时的运算，就用区域变量。请看下例：
Function
{
for i=0;i<10;i++
    {
      for j=0;j<5;j++
           {
              if Function1
                 {1;return}
 
           }
    }
0;return
}

Function1
{
for i=0;i<5;i++
    {
      for j=0;j<5;j++
           {
              if a==b
                 {1;return}
 
           }
    }
0;return
}
这个调用运行必然死机，为什么？
因为两个函数使用了共同的变量i和j,在运行Function1的时候，i和j都变成5；而在调用Function1的Function内，只要i<10都要执行下一个循环，而i永运停留在5的数值，就造成了死循环，因而SSP必然死机。所以应该把i改成_i,j改成_j来避免这种情况。

7.关于泛用阵列
AYA和C语言不同，C语言支持多维数组，而且数组大小必须定义，AYA只支持一维阵列的调用与赋值，数组大小不用定义。那么如何用AYA实现多维数组的效果呢？看下例：

a=IARRAY
for _i=0;_i<Numa;_i++
    {
     for _j=0;_j<Numb;_j++
             {
              a[_i*Numb+_j]=1

             }

    }
这个代码实现了把Numa行，Numb列的数据赋值为1，a[_i*Numb+_j]中，Numb是列数，_i*Numb就是第_i+1行开始时在阵列a中的索引位置，_i*Numb+_j就是第_i+1行第_j+1列在阵列a中的索引位置。
明白了这点，在需要调用阵列数据的程式里面，就方便了。