何谓AYA ?
AYA的日文即“あや”，汉字是“文”，由 umeiciさん 制作的高机能SHIORI，由于采用近似于C语言的写法，对于学过程式语言的人而言，特别容易上手。而对于没有相关背景的人格开发者，AYA的作者也提供了基础的人格范本*1，只要经过少量的修改，便能成为一个全新的人格。

AYA主要执行下述处理：

．对提供的字串进行加工
．根据程序的规则生成字串
↑
环境 ?
Windows用。

开发的初期版本有经过98SE、2000、xp的动作确认，不过最终版本并没有在XP以外的系统上作过动作确认。

↑
使用规定 ?
利用规定(作者原文)

．使途を限定せず自由に利用することが出来ます。 
(可以不限定用途的随意使用。)．配布パッケージに含まれているすべてのファイルを自由に取り扱うことが出来ます。
一部のファイル、もしくはそのファイルの内容の一部を拔き出して、他の构成に含めてもかまいません。 
(可以自由运用发布文件包装中包含的全部文件。)(取出一部份档案，或取出那个档案中的一部份内容进行二度制作也不介意。)．このプログラムを使用した结果、あなたに何らかの损害が発生しても、その责任を作者は负いません。 
(使用此程式后发生的任何问题，作者不予负责。)．ソースコードを改变して自由に异版を作成し、配布することが出来ます。
その际、配布者はその意志に基づいたライセンスを独自に策定し配布物に适用することが出来ます。 
(改变原始码并自行制成不同版本者，可自行发布。)(在此情况下，发布者能基于自己的意志自行制定适用于此发布物的认证。) ↑
汇出的函式 ?
文有以下被公开的函式。
文を利用するプログラムは、文をLoadLibraryした后にこれらの关数を实行して所望の处理を行ないます。

extern "C" __declspec(dllexport) BOOL __cdecl load(HGLOBAL h, long len)文初期化指示。
文をLoadLibraryして使用を开始する直前に、この关数を一度だけ必ず实行してください。
hには“文がカレントとして认识するディレクトリ绝对パス”を、lenはhの长さを渡してください。 hの领域开放は文侧で行ないますので、呼び出し侧では使い放しでかまいません。

extern "C" __declspec(dllexport) BOOL __cdecl unload()文终了指示。
文をFreeLibraryする直前に一度だけ实行してください。

extern "C" __declspec(dllexport) HGLOBAL __cdecl request(HGLOBAL h, long *len)文に处理を指示し、结果を得ます。
hには处理对象の文字列を、*lenにhの长さを渡してください。 渡したhの领域开放は文侧で行ないますので、呼び出し侧では使い放しでかまいません。 处理结果は戻り值で得られます。处理结果の长さは*lenに格纳されています（つまりこの值は书き换えられます）。 戻り值を取得した后、领域を*lenで示されるサイズで开放(GlobalFree)してください。

此外，这部份和桌面应用软体“伺か”使用的拟似AI用DLL“SHIORI”的介面规格完全是相同的。

↑
基础设定 ?
文 ver.5的预设DLL档名为“aya5.dll”。
主档名“aya5”可以自由地改为别的名字。

为了让文正常作动，被称为“基础设定档案”的档案是必要的。
基础设定档案的档案名为“主档名.txt”。即预设为“aya5.txt”。如果你把DLL的档案名改为“hoge.dll”的话，基础设定档案则为“hoge.txt”。

基础设定档案为TEXT文件、实行时以OS预设的文字编码来解读。
若要考虑国际化方面的情况的话，为了回避关于多位元组文字代码的问题、基础设定档案最好是设成ASCII编码。

以下述为例：

// dicsdic, basis.dicdic, control./*doc*/ayc// option parameterscharset, UTF-8msglang, englishlog, executelog.txtiolog, offfncdepth, 16设定时用逗号划分命令和参数。 空行(只换行的行)、‘//’后面单行文字、‘/*’到‘*/’包围的范围皆不会被读取。

命令和其意义为如下所示：

．charset, name 
标准文字编码的设定。
从以下的预约值任意选择一个。 没有指定的时候则预设作为Shift_JIS处理。


◦Shift_JIS / ShiftJIS / SJIS 
日文Shift_JIS编码。
◦UTF-8 
UTF-8。
◦default 
OS预设的文字编码。 

．dic, filename 
读取辞书档 filename。
辞书档为交付 AYA脚本 作为程式源始码的文件，文会根据此程式的内容进行作动。
辞书档指定多少，就能读取多少。

filename为load指定的路径位置的相对路径。
标准的辞书档是用 charset 指定的文字代码记述的平面文件。至于其他的，也可以用一定的法则来读取一些经过暗号化的乱码文件。


．msglang, language 
选择 log 记录的错误讯息所使用的语言。
从以下的预约值任意选择一个。 没有指定的时候则预设作为 japanese 处理。


◦japanese 
日本语。
◦english 
英语。 

．log, logfilename 
实行 log 档案 logfilename。
能用 charset 指定的文字编码写入。

logfilename 为 load 指定的路径位置的相对路径。


．iolog, [on|off] 
设定是否记录 load、unload、request 实行时的输入输出数据、字串及处理时间。
on为记录。预设为on，不需要时请设为off(节省系统资源)。


．fncdepth, depth 
指定一数值限制函式呼叫的深度上限。
预设值为32。最低值为2、比2还小或错误参数时也视为2。
↑
AYA脚本参照 ?
AYA脚本大致上的语法抄袭自C语言。 若曾学过C语言，在学习类似于C语言的AYA时便易于理解。

↑
函式 ?
↑
基础 ?
以下为request实行时能传回字串"Hello World"的代码。

   request   {       "Hello World"   }文读取此模组 HGLOBAL request(HGLOBAL h, long *len) ，实行此脚本后，便传回"Hello World"。

load与unload是同样的。
但因为load与unload不传回值、所以即使写入输出字串也没有意义。load为代入变数的初期值进行初期化处理、相反的unload将处理后的code写入。

只要写必要的函式就好。不必要的则可省略。
例如上例中的load和unload由于没有写入、因此也不会发生错误。仅仅是什么也没做。
举个极端的例子、即使完全没有辞书档也不会发生错误。这种场合下load和unload什么也没有做、 request则传回空的字串。

load和request有一个参数。可以用变数取出此值。
变数的名字为_argc和_argv、跟C语言的main函式的介面相类似。

↑
_argc ?
参数的数量。load和request的参数是一个字串，所以值为1。unload没有参数、因此值为0。

↑
_argv ?
参数的实体存在此处。此为具有_argc个元素的阵列。各元素中的存取位址为运算子[i]。
序数i从0开始。例如_argc是2的情况时可使用_argv[0], _argv[1]，参数会储存在此。

总结基础编的内容，load 将 "Hello" 收纳进变数str， request 将作为参数交出的字串与 str 结合后传回的程式码显示出来。

请以上述的说明为基础读读看。

   load   {       str = "Hello"   }   request   {       str + " " + _argv[0] + "!"   }将处理对象字串设为"World"交予 request 实行，可以得到 "Hello World!" 的结果。

↑
语法 ?
有以下之例：

1.空行（只换行的行）、"//"之后、及"/*"和"*/"包围的范围不会被读取。
2.1行的末端以斜线（"/"）作结时、下一行会与此行结合。
3.行头、以及单语间可自由放入空白文字。空白文字为空白及标记文字。
4.复数的叙述写在1行内的场合时、可以用分号（";"）区别开来。
也就是说先前举例的Hello World代码可以下列方式写在一行之中。

   request{"Hello World"}那么像以下这样的写法可以吗？　当然。运算上不会有问题。
（但是这种写法不是很好看！）

   req/   uest          {   "/   Hello World"  }斜线"/"的下一行（被重新结合的行）先头的空白文字会被判定为无效文字而消除。
同样的以下字串的结合结果为 "ABCDEFG" 、不会是 "ABCD　　EFG" 。

   "ABCD       EFG"第4项说明。
以下request为求1+2的答案、并传回句子。

   request   {       answer = 1 + 2       "答案是" + answer + "的样子。"   }用分号的话可以写成以下这样。

   request   {       answer = 1 + 2; "答案是" + answer + "的样子。"   }分号过多时不会造成问题。它们会被无视，不影响运算的结果。
相对的，如果你已经习惯C语言式的写法，也可以在每行的后面都加上分号。

↑
自定义函式的定义与实行 ?
除了 load、unload、request 以外也可以制作你自行取名的函式。
写好函式后，只要呼叫此函式即可使用。

   request   {       hello   }   hello   {       "Hello World"   }上面表示的是最单纯的例子。request的结果会传回"Hello World"。

为了完成一些工作，大部份的函式会需要一个或者是更多的参数(parameter)，而参数是让你可以传递一些资料到函式中。以下的例子可以得到与上述例子同样的结果。

   request   {       combine("Hello", "World")   }   combine   {       _argv[0] + " " + _argv[1]   }函式名后面加入( )，并在内部以逗号分列数值，这样一来这些值会作为参数交给该函式。即作为变数_argv和_argc的值，可在此函式内被提取。
在此举的例子当中、combine函式内的_argc为2、_argv[0]为"Hello"、_argv[1]为"World"。

函式名可以自由取名，但不能与下列的规则相扺触。

．用数字0～9作为第一个字。
．以下标线（"_"）为第一个字。
．包含以下文字。

     空白　!　"　#　$　%　&　(　)　*　+　,　-　/　:　;　<　=　>　?　@　[　]　`　{　|　}　~．与预约语完全一致。
函式重复呼叫是可能的。
举最常见的层乘计算式作为例子。

   request   {       factorial(5)   }   factorial   {       if !_argv[0]           1       else           factorial(_argv[0] - 1)*_argv[0]   }request传回120。

↑
字串选择 ?
   request   {       "Hello World"       "你好世界"       "Hallo Welt"   }像这样的例子的话、这三个句子会被视为同等的“输出候补”、输出三者之中的任意一个。

一共有5种选择方法，可以任意选择其中一种。
然而， void 与 array 是为特殊用途而用的。

↑
不指定 ?
预设为随机选择。

↑
nonoverlap ?
在所有的候补都被选过之前，不会选择重复的选项。

         request : nonoverlap         {             "Hello World"             "你好世界"             "Hallo Welt"         }像上列这样在函式后面附加": nonoverlap"。

↑
sequential ?
上至下按顺予输出。输出到最后时，会返回先头。

         request : sequential         {             "Hello World"             "你好世界"             "Hallo Welt"         }像上列这样在函式后面附加": sequential"。

↑
void ?
什么都不输出。
以下的场合、request 3个候补都不会输出。

         request : void         {             "Hello World"             "你好世界"             "Hallo Welt"         }“什么都不做”与“什么都不输出”之间的差别请注意一下。
函式内部的函式与算式仍然是会被处理的。

         increment_i : void         {             i++             i         }上列函式中increment_i的i会进行1的加算。在没有void的场合下、此函式会传回加算的结果、在有指定void的场合下，不会传回任何的值，仅只是进行了加算的动作。

↑
array ?
输出候补会全部集成一个泛用阵列作为函式的返值。

         request : array         {         　　"This is a pen."         　　("A","B","C")         　　3.14         }输出结果等同于泛用阵列 ("This is a pen.", "A", "B", "C", 3.14) 。

nonoverlap和sequential即使在具有输出确定子的情况下，也能取得所有的组合进行正常的运作。
举sequential的例子来说：

   request : sequential   {       "1"       "2"       "3"       --       "A"       "B"   }request会照以下顺序输出。

   "1A" "2A" "3A" "1B" "2B" "3B" "1A" "2A" …有时函式会使输出候补数量产生变动。
例如以下的函式会因为变数i的值而使候补数由2个变成4个。

   request : sequential   {       if i {           "1"           "2"       }       "3"       "4"   }当候补数产生变化后、nonoverlap和sequential的巡回顺序会初期化，重新回到一开始的状态。唯有此时才有可能输出和上回相同的值。

↑
子阶层{} ?
   request   {       {           "Hello World"           "你好世界"       }              "Hallo Welt"   }{ } 可以阶层式的重复书写。其中变化与最高层的{ }相同，会在包含其中的候补挑选一个输出。
但只能以随机的选择方法，无法像最上层那样指定nonoverlap或sequential。

从上述来看，{ }的有无似乎是一样的，但实际上不是这样。
在没有{ }的场合、输出的机率大约是平等的1/3。然而在上述的例子看来、首先会从"Hello World"与"你好世界"之中挑选一个出来、然后挑选出来的再与"Hallo Welt"进行二选一。所以说，三者的出现率为"Hello World"与"你好世界"为1/4，"Hallo Welt"为1/2这样。

↑
输出确定子 ?
   request   {       "Hello"       "Perfect"       "Peaceful"       --       " Wor"       --       "ld"       "th"   }‘--’作为输出确定子，会将选择候补的范围切开来分成各自的小组。然后，将各小组选出来的结果互相结合。
如果实行上述的request的话，会产生下列任一种结果。

   "Hello World"   "Perfect World"   "Peaceful World"   "Hello Worth"   "Perfect Worth"   "Peaceful Worth"与nonoverlap、sequential组合使用的场合下，（グループ单位ではなく）函式会根据取得的所有组合进行相对的动作。

输出确定子在任何地方都可使用，即使在{ }很深的情况下。

文也能处理同时有字串与数值的情况。
输出确定子会在结合时全部转换为字串与字串的结合。

↑
值与变数 ?
↑
即值 ?
文能处理的值为整数、实数、字串3种类。

．整数 
带符号32bit整数。

一般为10进位数值。
在前头附加"0b"的话、可记述2进位数值。
在前头附加"0x"的话、可记述16进位数值。

以下的函式int10会传回整数10。因为3种记述方式以10进位来看都一样是10。
         int10         {             10             0b1010             0xa         }．实数 
带符号64bit浮动小数点数。数值在小数点以下的场合、或是精确度落差非常巨大的场合时可以使用这个。
与整数的差别在于小数点的有无。文在数值上有小数点的时候，会作为实数处理。
．字串 
双引号（"）包围的值为字串。
字串中不可含有双引号。
．字串（无展开） 
单引号（'）包围的值，不进行展开动作的单纯字串。
文能在字串中插入变数或函式的这个功能，是在有展开被双引号包围的字串才有。
字串中不可含有单引号。
↑
变数 ?
变数为保存值的领域。
变数可以保存：

．整数、实数、字串
．可以保存上述三者的泛用阵列
上述的这几种。

名字在不触犯以下禁止条款的前提下可自由设置。

．以数字0～9为始。
．包含以下文字。 
     空白　!　"　#　$　%　&　(　)　*　+　,　-　/　:　;　<　=　>　?　@　[　]　`　{　|　}　~．与预约语完全一致。
．与函式名完全一致。
值的保存（指派）由指派运算子 = 来执行。要输出内容的话、与函式一样写下变数的名字即可。

   request   {       str = "你好"              str   }上面为最单纯的例子、变数str存取字串、并照着那样输出。

若是未指派值的变数，则会输出空的字串。
注意并不是“什么也不输出”。

   request   {       "Hello World"       i   }i 并不存在，因此为空的字串，结果上面的例子与下面的写法等价，因此有1/2的机率会输出"Hello World"或空字串。

   request   {       "Hello World"       ""   }↑
变数的范围与寿命 ?
变数有两种不同的scope（有效范围）。

．全域变数(global variable)
所有函式皆可共通使用的变数。寿命为永远。
．区域变数(local variable)
现在的{ }内、以及其下更深的子阶层可以使用的变数。寿命为当此{ }结束的时候。
两者的区别为变数的名字。变数名前头有下标线（"_"）的变数为区域变数。
以“只在必要范围内有效的变数”的观念善用区域变数的话、可以有效提升程式的品质。

   request   {       _i = "3*2等于"              _j = multi(3)              _i +_j + "的样子"   }   multi   {       _i = _argv[0]       _i * 2   }request与multi虽然使用了同样名字的变数 _i，但两者被视为完全无关的值来运算，也不会互相干扰。

你或许也察觉到函式的参数所使用的变数_argc和_argv同样也是区域变数。
这也是因为其他的函式也都需要存取一些不同的值，所以才将其作为区域变数。

区域变数并非是“在现在的函式内可以使用的变数”，而是“现在的{ }内、甚至更深的阶层都可使用的变数”，这点请注意一下。

   request   {       {           _str = "Hello World"       }              _str   }这个程式无法照着我们希望的那样动作。
_str在{ }内是有效的、但是到了输出取值的时候却消失了。
结果，这个函式request输出的是空字串。
要正确产生结果，则应该预先宣告变数。如下所示：

   request   {       _str = ""              {           _str = "Hello World"       }              _str   }全域变数与区域变数的差异就在这里。就是寿命。
照上述所说区域变数的规则、变数在现在使用的{ }之外便会消失。
相对的全域变数在哪里都可使用、此外unload后此值会被自动储存在档案里面，等到load后又可再度复元。意即全域变数的内容（在没有特别的操作或意图使其消去的前提下）是可以永久保存的。

↑
运算 ?
↑
基本 ?
与C语言同样写法的四则运算、比较运算、指派、及其他可能的运算。
演算顺序为当运算子重复堆叠时基于演算优先度来决定的。还有、括弧( )包围的部分为最优先演算顺序。

运算子的种类与演算优先度如下。

运算子 意义 优先度 
( )　[ ] 括弧 高 
! 否定* 
 
++　-- 递增*/递减* 
 
*　/　% 乘除算、除余 
 
+　- 加减算 
 
& 反馈* 
 
==　!=　>=　<=　>　<　_in_　!_in_ 比较 
 
&& 论理积 
 
(注) 论理和 
 
=　:= 指派 
 
+=　-=　*=　/=　%=　+:=　-:=　*:=　/:=　%:=　,= 演算并指派 
 
, 泛用阵列要素的列举 低 

(注)论理和为 ||附有冒号（":"）的指派运算子乃因旧有版本的相容性而保留的，功能上与没有冒号的指派运算子完全相同。*为单项运算子。括弧( )相关内容会在次项中详细说明。
逗号运算子（","）、方括弧[ ]会在阵列的项目中详细说明。
反馈运算子&会在别项中详细说明。


_in_与!_in_为字串中包含校验功能的运算子。

   foo   {       "or" _in_ "World"   }_in_ 若左边字串在右边字串中有相符字串的话传回1、如果没有的话传回0。!_in_为相反。
上述函式foo传回1。

比较运算子的结果是真时传回整数1、伪时传回0。
这些运算子同样也适用于字串。值的大小则根据辞书顺序的比较来决定。

逻辑真伪的判断。

伪　 整数0、实数0.0、空字串、空泛用阵列 
真　 上述以外的全部值 

没有指派的运算会直接输出结果。

   foo   {       (3+2)*4   }此函式foo最后会输出20。

同样优先度的运算子连续出现的场合下，通常由左开始结合。

   1+2-3例如上式为 
(1) 1+2 
(2) 3-3 
的顺序进行计算。 


   i = j = 10至于这种例子又怎么说呢？因为C语言的指派运算子为由右至左的演算，所以 i 与 j 都被指派了10的值。 
然而文在结合时常由左边开始。即 
(1) i = j 
(2) j = 10 
这样的顺序计算下去。结果、i 无法变成10的值。

   i = (j = 10)改成这样写的话 i 就可以得到10的值了。

演算对象项目的型别不一致的场合下、最终结果的型别如下列所示。

．整数与实数的演算 
结果为实数。
．整数/实数与字串的加算 
数值转换成字串后、再与字串结合。
．整数/实数与字串的演算（加算以外） 
无法演算但也不会产生错误。结果为空字串。
即使在一个演算式内混合多种的型别也没关系。
必要的话、会根据上述法则产生型变。

   "10+2等于" + (10+2) + "的样子。"一开始是10+2的整数计算，得到的值为12。接下来为所有字串的加算，12转换成字串，作为字串组合在一起。

↑
有括弧( )时的演算顺序 ?
括弧( )包围的部分为演算顺序中最优先展开的。
( ) 可以任意重复指定、愈深的优先度愈高。

平白的说就是“从包围最深的地方先开始计算”。因为这是理所当然的规则，所以也不用特别在意。不过按照数式的写法也是可以弄得非常复杂的。
以以下例子来看。

   answer = (_i = 10) + (2*(_i + 10))对于不理解文的演算法则的人来说，很难保证answer会是怎样的值吧。
answer其实是字串的"10"。绝对不是整数50。

最初的计算在哪？括弧最深的地方、也就是 _i + 10 。那么变数 _i 还不存在，因而变成空字串。再来、_i + 10 为字串与整数的加算。10也变成字串、也就是"10"。但是接下来为与整数的乘算、结果又变成了空字串。
说到这里应该明白为何是字串的"10"原因了吧。

那么、这边的意图首先是让_i = 10的指派成为最初的演算。
像这种时候、文的方法即为追加更多的括弧来控制演算的顺序。

   answer = (((_i = 10))) + (2*(_i + 10))这样一来指派的优先度就大为提升。这回应该便能得到正确的结果了。

然而，如果你以为将括弧加到第2层即可的话，那你又错了。括弧2段的话虽然与 _i + 10同样深度，但是 = 与 + 相比优先度是 + 的那边较高。

↑
反馈运算子& ?
反馈运算子&是用法完全不同于别的运算子的独特运算子。

   request   {       _i = 1       foo(&_i)   }   foo   {       _argv[0] = 100   }呼叫函式时将变数作为参数的时候、可以在变数的前面加上&。前头附有&的变数可以与原先叫出函式相对应的_argv的元素产生关联。也就是说、当_argv的值改变的时候、其对应的原呼叫变数的值也会改变。
就上面的例子、foo实行后 _i 的值也会变成100。

反馈运算子可以自由的在不同地方多次使用。

   request   {       foo(1, 2, &_value, "Hello", &_value2)              _value + _value2   }   foo   {       _argv[2] = _argv[0] + _argv[1]       _argv[4] = _argv[3] + " World"   }函式request最终传回 "3Hello World" 。

当然的、反馈运算子只能使用在变数上面。

↑
阵列 ?
运算子[ ]为用于存取阵列元素的运算子。

阵列分为在字串区分元素来拟似阵列型式的“简易阵列”，以及以逗号区分、详细列举阵列元素的“泛用阵列”这两种类。

↑
简易阵列 ?
将字串中含有的逗号视为分隔符号(划分的符号)，并像阵列般进行处理。
简单的说，简易阵列其实就是字串，只是用了类似处理阵列的方式进行演算。

   request   {       _a = "this,is,a,pen"       _a[1]   }request最后输出"is"。

[ ]运算子处理的对象并不一定是变数，即值与函式的返值也是可以的。
上述例子也可写成如下例这样。

   request   {       "this,is,a,pen"[1]   }在[ ]运算子中的第二项参数可以自行指定分隔符号(delimiter)，用逗号以外的文字作为划分阵列元素的根据。

   request   {       "This,is,a,island."[2,"is"]   }上述即以"is"来进行区分，字串最终会被分解成这样。

   [0]　"Th"   [1]　","   [2]　",a,"   [3]　"land."request因而传回",a,"。

如果善用分隔符号的话，要做出类似多次元阵列格式的值也是有可能的。

   request   {       _ar = "taro|male,ayame|female,hotaru|female"           _ar[2][1,"|"]   }_ar[2]即为"hotaru|female"。接下来再将"|"作为划分文字将"hotaru|female"中的[1]取出的话、结果即为"female"。像这样每个阶层都使用独特的分隔符号的话，便可以轻松取得任意位置的值。

当你指定范围以外的序数时，会跟取出不存在的变数的情况一样，传回的值为空字串。

这边开始为变数才能使用的功能。

可以指派阵列元素。

   request   {       _a = "this,is,a,pen"       _a[3] = "eraser"       _a   }"pen"会被替换成"eraser"。request的实行结果为"this,is,a,eraser"。

在有指定分隔符号的情况下也能正常运作。

   request   {       _s = "This,is,a,island."       _s[2,"is"] = ",beautiful,"       _s   }request会输出"This,is,beautiful,island."。

在与多次元阵列[ ]运算子连结使用的时候，则无法指派( = )运算子。

   request   {       _ar = "taro|male,ayame|female,hotaru|female"           _ar[1][1,"|"] = "male"   }上述式子想把ayame的性别改为male，但却会发生错误。只有在一次元的情况下才能指派。

指派的位置即使超过现有的元素数量也没关系。分隔符号会自动追加，扩张元素数量。

   request   {       _m = "fuji/asama/tanigawa"       _m[5,"/"] = "daisen"       _m   }request会输出"fuji/asama/tanigawa///daisen"。

如果使用叫做SETDELIM的函式的话，便能将“预设的分隔符号”从逗号改为其他的字串。 上述例子如果用SETDELIM来写的话，会变成下面这样。

   request   {       _m = "fuji/asama/tanigawa"       SETDELIM(_m, "/")       _m[5] = "daisen"       _m   }运行SETDELIM之后，只要写_m[5]即可。

在与多次元阵列[ ]运算子连结使用的情况下、SETDELIM只对最初的（一次元的）[ ]有效。

↑
泛用阵列 ?
泛用阵列是可以保存各种不同型别的值的阵列构造。
一般的存取速度要比简易阵列快得多。

↑
初期化 ?
   i = (100,"test",-1.5)用逗号列举阵列元素并记述。
在指派的时候请像上面一样将元素的集合用( )围起来。因为逗号的演算优先度低于指派运算子( = )，如果没有这么做的话会被

   (i = 100),"test",-1.5这样子解释。

要使阵列呈现无元素状态的初期化，请使用IARRAY这个函式。IARRAY为会传回“空的泛用阵列”的函式。

   i = IARRAY初期化时如果只有指派一个阵列元素时得另外做点功夫。假如只有指派i = 100的话，因为不是阵列的关系，会被视为单纯的指派100的值。
请照下述方式记述。

   i = (IARRAY,100)↑
阵列元素的追加 ?
   i = (i,"add")这样写的话会在阵列i的后端追加"add"这个元素。

也可以追加阵列。

   i = (i,("add",123,0.0))就像a = a + 1 同等 a += 1这样的省略法，上述例子也可以写成像下面这样。

   i ,= ("add",123,0.0)也可以在阵列的前端插入元素。

   i = ("first",i)也可以在阵列的中间插入元素。

   i = (100,200,300,400,500,600)   i[2] ,= "insertion"i即为(100,200,300,"insertion",400,500,600)。
要注意的是插入的值是追加在i[2]的后面，所以当你要取这个值的时候不是取i[2]而是取i[3]。想插入i[2]的位置的话请

   i[2] = ("insertion",i[2])这样子写。

↑
阵列元素的削除 ?
将要削除的元素指派给IARRAY。

   i = (100,200,300,400,500,600)   i[2] = IARRAY300于是被削除、i变成(100,200,400,500,600)。

↑
值的更新 ?
可以单纯的指派元素。

   i = (100,200,300,400,500,600)   i[2] = 700i变成(100,200,700,400,500,600)。

指派的位置即使超过现有的元素数量也没关系。阵列会自动扩张元素数量。

↑
值的取出 ?
与通常的变数一样，被指定的元素若存在便输出此阵列元素。

当你指定范围以外的序数时，会跟取出不存在的变数的情况一样，传回的值为空字串。

   i = (100,200,300,400,500,600)   i[4]最后输出500。

[ ]运算子处理的对象并不一定是变数，即值与函式的返值也是可以的。

   (100,200,300,400,500,600)[4]最后输出500。

泛用阵列也可直接作为函式并输出。

   request   {       river[2]   }      river   {       "tenryu","bandou-tarou","ishikari","shimanto"   }request会输出"ishikari"。

↑
无法多次元化 ?
泛用阵列无法组合成多次元阵列。

   (100,200,(300,400),500,600)用这样的写法时，括弧内包的部份并不会被视为第二次元的阵列。
结果像以下一样单纯的结合。

   (100,200,300,400,500,600)↑
演算 ?
元素单位的演算一般来说是可以的。

比较独特的是，泛用阵列的单项值在演算的时候，是 
“全元素的单项值都进行演算”。

       pref = ("gunnma","ohsaka","hokkaido")       pref += "-ken"       answer = (2*(1,2,3))[1]pref会变成 "gunnma-ken","ohsaka-ken","hokkaido-ken" 。

answer的结果是4。
2*(1,2,3)的计算结果为(2,4,6)。

↑
函式的参数 ?
在文的体系中，函式的参数为泛用阵列。_argv的内容即为函式呼叫时所代入的参数。

也就是说

   func(1, 2, "test")与这样的函式呼叫、

   _i = (1,2,"test")   func(_i)都可以写入。这是相当重要的记述。
请注意，这个script在运行的时候，参数的数量绝对不是1个。而是3个！
此时func内_argv[0] = 1，_argv[1] = 2，_argv[2] = "test"。

善用这种构造的话，可以从其他的函式中简单的取得可变长的参数。

   request   {       total(1,2,3,4,5,6)   }      total   {       calc_total(_argv)   }      calc_total   {       _answer = 0;       foreach _argv; _val { _answer += _val }       _answer   }total本身完全没有做什么事，只是单纯的将所有的参数传给calc_total。
这例子是单纯的传递，当然也是可以在此过程中经过必要的加工后再传递。

参数的指定方法较为复杂的情况下需要注意几点。

   _i = (1,2,"test")   func("sky", _i, "sun")上述的呼叫与下例同等。使用泛用阵列时请记得它无法多次元化。

   func("sky", 1, 2, "test", "sun")↑
分隔符号/取得数指定 ?
   _i = (2,"is")   "This is a island."[_i]简易阵列在指定分隔符号的部分也是泛用阵列。所以也能像上述这样子写。与下述写法为等价。

   "This is a island."[2,"is"]↑
范围指定 ?
简易阵列/泛用阵列都可指定序数的范围，也可以取得或代入。

范围可用泛用阵列来指定。例如 i[a,b] 可表示为“i的元素a～b”。

   name = ("さくら","せりこ","奈留","まゆら","毒子","美耳")   i = name[1,3]   name[3,4] = "奎子"   j = name   name[0,2] = IARRAY   k = namei变成 ("せりこ","奈留","まゆら") 。
j变成 ("さくら","せりこ","奈留","奎子","美耳") 。
k变成 ("奎子","美耳") 。

范围外则自动无视。

   n = (1,2,3,4)   n[-2,1] *= 5n为 (5,10,3,4) 。

对象是简易阵列的时候也是一样。

   name = "さくら,せりこ,奈留,まゆら,毒子,美耳"   i = name[1,3]   name[3,4] = "奎子"   j = namei为 "せりこ,奈留,まゆら" 、jは "さくら,せりこ,奈留,奎子,美耳" 。

指定范围后再接着指定分隔符号也是可能的。

   animal = "熊！兔！猫！狗！鳄"   i = animal[0,2,"！"]   animal[2,4,"！"] = "猪"   j = animali变成 "熊！兔！猫" ，j变成 "熊！兔！猪" 。

↑
泛用阵列的平行输出 ?
所有的式/值的前面都可写上“parallel”。
具有parallel的泛用阵列在作为输出候补值的时候，能将阵列中所有的元素视为输出候补值。

   foo0   {   　　("A","B","C")   　　"地球"   }      foo1   {   　　parallel ("A","B","C")   　　"地球"   }foo0的输出会是("A", "B", "C") 或 "地球"。
foo1的输出会是"A"、"B"、"A"、"地球" 这四种。

把parallel用在泛用阵列以外的值的时候，有写跟没写一样。例如下面的2种写法是等价的。

   parallel STRLEN("earth")   STRLEN("earth")在使用字串选择模式array和parallel的时候，可以与函式的输出候补和泛用阵列互相配合使用。
可以有各式各样的应用方式。例如以下非常简洁的函式cyclic，会把泛用阵列的所有元素按照前后顺序取出来。

   request   {    _i = ("甲","乙","丙")    cyclic(_i)   }      cyclic : sequential   {   　　parallel _argv   }↑
字串内埋入元素的展开 ?
可以在字串的中埋入变数或函式，并把实行的结果插入其位置上。

↑
附带范围的展开 ?
将埋入的元素以%( )包围。

   request   {       _i = "pen"       "This is a %(_i)."   }request实行后，会输出"This is a pen."。

%( )会进行类似eval（将字串解释为Script code并实行）的动作。可以是单一的函式或变数，甚至是算式也没问题。

   request   {       "1+2+3等于%(1+2+3)。"   }request会输出"1+2+3等于6。"。

请注意，文的字串中无法包含双引号，因此不能插入含有字串的算式。以下例子会产生错误。

   request   {       "This is a %(_i = "pen")."   }像这种时候，要将算式区隔出来。

   request   {       "This is a " + (_i = "pen") + "."   }有括弧( )的演算顺序控制与附带范围的展开是同样的程序。 
请看以下的例子。

   request   {       "行星“%(_i = planet)”离earth很远。这个行星的颜色是%(color(_i))。"   }      planet   {       "mars"       "saturn"       "pluto"   }      color   {       case _argv[0] {       when "mars";   "red"       when "saturn"; "yerrow"       when "pluto";  "blue"       others;        "unknown"       }   }由于最深的( )为color(_i)的参数，所以会在执行_i = planet之前就先呼叫函式color。 
在这种情况时，请增加额外的括弧来调整演算顺序。

   "行星“%((_i = planet))”离earth很远。这个行星的颜色是%(color(_i))。"这样一来即可得到没有矛盾的字串。

↑
名称最长一致展开 ?
没有授与( )时、单纯埋入%时所展开的机能。

   request   {      o      = "pen"      obj    = "eraser"      object = "world"      "This is a %object."   }      obje   {       "television"   }其展开的对象为%后面的字串中相符并具有最长一致性的变数/函式。在上面的例子中，一致性最高的变数为object，因而采用此变数。结果会变 成"This is a world."，而不是"This is a televisionct."或"This is a eraserect."。

由于变数时时刻刻都在作成与消失，因此展开的对象也会根据状况而有所变化。
这是附带范围的展开时所没有的特性。

   request   {      val   = "red"      trans      --      value = "blue"      trans   }      trans   {       "%value"   }trans被实行了两次，然而第一次与第二次的"%value"的动作是不一样的。此意味着最初的运行被视为变数val+"ue"，第二次则被解释为变数value。
request会输出"redueblue"。

使用%[ ]语法的话可以呼叫过去的展开结果。

   request   {       "“%planet”很远。“%city”也很远。不过%[0]比%[1]更远。"   }      planet   {       "mars"       "saturn"       "pluto"   }      city   {       "newyork"       "moscow"       "madrid"   }%[i] 为从 0 开始的第 i 次展开结果。
也就是说在上述的例子中，%[0] 会显示 %planet 的展开结果，%[1] 会显示 %city 的展开结果。

%[ ]在附带范围的展开中无法使用。想要再利用附带范围展开的过去结果的话，请使用变数。

由于名称最长一致展开在运行过程中会对展开的对象进行检索，所以和附带范围展开相比，动作速度上会慢上很多。
因此在没有必要的时候，请使用附带范围展开%( )。

↑
流程控制 ?
↑
if的分歧 ?
式的判定结果为真时则继续处理{ }内的式子。

   request   {       if !i {           "i为0。"       }   }可以在后面加入elseif。会在if的判定为伪的时候进行处理。
elseif可连续使用。
另外，if～elseif的最终端可加入else。会在前端if及elseif的判定皆为伪的时候进行处理。

   request   {       if !i {           "i为0。"       }       elseif i == 5 {           "i为5。"       }       elseif "A" _in_ TOUPPER(i) {           "i为字串，并且含有a或A。"       }       else {           "i不是0或5或含有a的字串。"       }   }if、elseif、else在处理script时若只有一行的话、{ }可省略。因此上述程式码可写成如下所示。

   request   {       if !i           "i为0。"       elseif i == 5           "i为5。"       elseif "A" _in_ TOUPPER(i)           "i为字串，并且含有a或A。"       else           "i不是0或5或含有a的字串。"   }但是在if重叠的时候{ }不可省略。以下式子在C语言中是正确的，在文中是错误的。

   if i == 0       if j == 0           "i和j都是0。"以下式子的{ }是必要的。

   if i == 0 {       if j == 0           "i和j都是0。"   }和C语言一样，if的判定式可以用括弧( )将全部式包围住。
其运作和不包围的时候没有两样。
可以使用if、elseif、case、while、for、switch的判定式。

↑
case的分歧 ?
case可实现条件分歧的构造。

   request   {       case i {           when 0 {               "i为0。"           }           when "A"               "i为字串A。"           others {               "i不是0也不是A。"           }       }   }case会实行与判定式结果一致的值所对应的when片段。
others在代入的值与所有条件叙述的值都不一致的时候才会执行。others可以被省略。

when可以用逗号列举两个值以上的条件叙述。另外也可以用减号‘-’来指定条件的范围。

   request   {       case name+(i+1) {           when "Pentium3","Pentium4"               "Pen!!!在1999年发售，而Pen4则在2000年发售。"           when "Pentium5"-"PentiumX" {               "还没有。"           }           others               "我不知道。"       }   }when所记述的条件式必须是即值，不能含有变数或函式、运算子。

when、others在处理script时若只有一行的话，{ }也可像if一样省略。

↑
switch的分歧 ?
当你想要自行选取{ }内的输出候补的话，使用switch的话即可指定输出候补的位置。

   request   {       switch id {           "id为0。"           "id为1。"           {               "id为2。"               "id为two。"           }           "id为3。"       }   }会依照变数id的值来指定输出的字串。指定的值从0开始。
id为2的时候，会输出"id为2。"或"id为two。"。在此{ }所包含部分的选择为随机。

当switch的参考值所对应的候选不在{ }内时输出空字串。例如说、在上述例子中若id等于100，便会输出空的字串。

当switch内含有输出确定子( -- )的时候，会选择各小组在此值所配对的输出候补。

   request   {       switch 1 {           "かわいい"           "天才"           "サル"           --           "とは言い难い"           --           "ですね。"           "かもしれません。"       }   }request的输出会变成"天才かもしれません。"。
中间的小组因为指定位置没有候补，所以输出空的字串，这点请注意一下。

↑
回圈(loop) ?
共有while、for、foreach这3种回圈构造。

↑
while ?
while是最简单的回圈形式，当条件为真时会重复执行{ }内的动作。

   request   {       _i = 1       _j = 0       while _i < 11 {           _j += _i           _i++       }              "将1到10全部加起来的话，可得到%(_j)。"   }上面的例子可以简单说明while的功能。

下面的例子会产生10个不同的字串。request的输出结果为报告1～10其中任一个数的平方根的字串。

   request   {       _i = 1       while _i < 11 {           "%(_i)的平方根为%(SQRT(_i))。"           _i++       }   }↑
for ?
for是与while同样的先判定回圈构造，其特色在于会在回圈开始前指定其初期化式、脱出判定式、回圈执行式。

while的例子用for来写的话可写成下面所示。

   request   {       for _i = 1; _i < 11; _i++ {           "%(_i)的平方根为%(SQRT(_i))。"       }   }_i = 1会在回圈开始前执行。_i < 11为回圈的条件式、如果条件为真时则回圈继续执行。_i++会在回圈执行完一轮之后、开始新的一轮之前的时候执行。

C语言可用 for ( ; ; ) 作为无限回圈，文的话各式的省略不可。
制作无限回圈的时候，

   for 1;1;1请这样子写。不过，用while的话

   while 1这样子写就行了。因此文在制作无限回圈的时候，不管是从可读性或是动作速度的角度来看，都建议使用while回圈。

↑
foreach ?
照顺序取出简易阵列或泛用阵列的各元素值。

以下例子为取出简易阵列的元素进行数值的转换，再将这些数值全部加起来后输出其结果。

   request   {       _str = "1,3,5,7,9"       _t   = 0       foreach _str; _i {           _t += TOINT(_i)       }       _t   }foreach会持续记述处理对象。上面的例子中foreach指定简易阵列为_str，然后依次将取出的阵列元素储存在变数_i中。

即使处理对象的分隔符号被SETDELIM改变了也没关系，foreach会依照此分隔符号正常的运作。

foreach可处理泛用阵列。

   request   {       _sent = ("I", "am", 31, "years", "old.")       _t   = ""       foreach _sent; _i {           _t += (_i + " ")       }       _t   }request会输出"I am 31 years old. "。

即使在foreach回圈内将元素取出对象的简易阵列、泛用阵列进行更改也没关系。
变更会正常的反映出来。

↑
break ?
回圈中出现break的话，会跳出现下实行中最深的回圈。

   request   {       _j = 0       for _i = 0; _i < 100; _i++ {           _j = _i*_i           if  _j >= 100               break       }       _i - 1   }上述的例子中、for为初期值0的_i实行至_i达到100才结束的回圈。然而，由于回圈内有被解释为“_i 的平方值大于等于 100 时便跳脱回圈”的break存在，因此实际上在 _i = 10 的时候回圈便会结束了。

request会传回比_i小1的值，也就是说整个函式request的实际意义为“求平方的结果不超过100的最大整数”。

↑
continue ?
回圈中出现continue的时候，会回到回圈的开头。

   request   {       _j = ""       for _i = 0; _i < 3; _i++       {           _j += "go "           if  _i > 0               continue           _j += "ahead "       }       _j   }_i在0、1、2之间变化，当_i等于1、2时continue会被执行，此时_j就不会被追加"ahead "字串。 因此request的输出会变成"go ahead go go "。

↑
return ?
return出现时，函式的运行便会在此结束。
函式的输出会从到目前为止所产生的候选中挑选。

   to_rad   {       if GETTYPE(_argv[0]) == 3 {           -1           return       }       _argv[0]*2.0*3.14/360.0   }函式to_rad会将角度的单位从度转换为弧(radian)。
若参数为字串时，if条件式会判定为真而传回-1。由于return发生的时候仅有-1这个输出候补，因此只会输出此一值。

↑
预处理(preprocess) ?
预处理为读取辞书档案阶段时所执行的命令。

↑
#define ?
在读取辞书档案之前（pass前的）产生的字串进行比对，并且直接将字串置换。

   #define before after在读入此记述后，若发现before这个字的话会自动置换成after。


#define 的有效范围从宣告的下一行开始直到这个档案的终端。

按记述的顺序进行置换，写在前头的先变换。

↑
#globaldefine ?
   #globaldefine before after功能与 #define 命令相同，但是两者的有效范围不同。


#globaldefine 宣告后，下一行后的全部范围（也包括之后读取的辞书档案）皆有效。也就是说，如果在最初读取的辞书档案前头记述 #globaldefine 的话，其有效范围即为所有的辞书档案。

#define会先被处理。#globaldefine 在#define 置换后才被执行。

   #globaldefine tea green   #define tea milk   "teacup"置换结果为"milkcup"。

↑
预约语 ?
以下的单字为系统函式名及控制命令名。
这些名字在文的系统中被保留了。使用者不能作成和这些名称完全相符的函式或变数。

TOINT　TOREAL　TOSTR　GETTYPE　ISFUNC　ISVAR　 LOGGING　GETLASTERROR　LOADLIB　UNLOADLIB　REQUESTLIB　CHARSETLIB　RAND　FLOOR　 CEIL　ROUNDSIN　COS　TAN　LOG　LOG10　POW　SQRT　STRSTR　STRLEN　REPLACE　SUBSTRERASE　INSERT　TOUPPER　TOLOWER　CUTSPACE　TOBINSTR　TOHEXSTR BINSTRTOIHEXSTRTOI　CHR　FOPEN　FCLOSE　FREAD　FWRITE　FWRITE2　FCOPY　FMOVE MKDIR　RMDIR　 FDEL　FRENAME　FSIZE　FENUM　FCHARSET　ARRAYSIZE SETDELIM　EVAL　ERASEVAR　 GETTIME　GETTICKCOUNT　GETMEMINFO RE_SEARCHRE_MATCH　RE_GREP　SETLASTERROR　 RE_REPLACE　RE_SPLIT　RE_GETSTR RE_GETPOS　RE_GETLEN　CHRCODE　ISINTSTR　 ISREALSTR　IARRAY　SPLITPATH CVINT　CVSTR　CVREAL　LETTONAME　LSO　STRFORM　ANY　 SAVEVAR GETSTRBYTES   if　elseif　else　case　when　others　switch　while　for　break　continue　return　foreach以下的单字/文字为运算子。
使用者无法作成、利用与这些名称完全一致的变数或函式。还有，变数或函式名也不能含有这些单字/文字。

   (　)　[　]　!　++　--　*　/　%　+　-　&　==　!=　<=　>=　<　>　_in_　!_in_　&&　||   =　:=　+=　-=　*=　/=　%=　+:=　-:=　*:=　/:=　%:=　,= ↑
谢辞 ?
以下のライブラリを利用もしくは参考にさせていただきました。感谢致します。

．マルチバイト文字列 - ワイド文字列变换クラス CUnicodeF
http://kamoland.com/comp/unicode.html
正规表现ライブラリ Boost::Regex
本家
http://www.boost.org/libs/regex/doc/index.html
日本语译
http://boost.cppll.jp/HEAD/libs/regex/index.htm
VC6へのインストール方法
http://village.infoweb.ne.jp/~fwhk9290/behind/regex.htm
基本的な使用方法
http://www.s34.co.jp/cpptechdoc/article/regexpp/
